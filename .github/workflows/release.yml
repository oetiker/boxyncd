name: Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        type: choice
        options:
          - bugfix
          - feature
          - major

env:
  CARGO_TERM_COLOR: always

jobs:
  wait-for-ci:
    name: Wait for CI
    runs-on: ubuntu-latest
    steps:
      - name: Wait for CI to pass
        uses: actions/github-script@v7
        with:
          script: |
            const deadline = Date.now() + 180_000;
            while (Date.now() < deadline) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'ci.yml',
                branch: 'main',
                per_page: 1,
              });
              const run = runs.data.workflow_runs[0];
              if (!run) {
                core.info('No CI runs found yet, waiting...');
              } else {
                core.info(`CI: status=${run.status} conclusion=${run.conclusion}`);
                if (run.status === 'completed') {
                  if (run.conclusion === 'success') {
                    core.info('CI passed!');
                    return;
                  }
                  core.setFailed(`CI ${run.conclusion} â€” aborting release`);
                  return;
                }
              }
              await new Promise(r => setTimeout(r, 10_000));
            }
            core.setFailed('Timed out waiting for CI after 3 minutes');

  version:
    name: Bump Version
    needs: wait-for-ci
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate new version
        id: version
        uses: actions/github-script@v7
        with:
          script: |
            if (context.ref !== 'refs/heads/main') {
              core.setFailed('Releases must be created from the main branch');
              return;
            }
            const tags = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });
            const latest = tags.data
              .map(t => t.name)
              .filter(t => /^v\d+\.\d+\.\d+$/.test(t))
              .sort((a, b) => {
                const pa = a.slice(1).split('.').map(Number);
                const pb = b.slice(1).split('.').map(Number);
                return pa[0] - pb[0] || pa[1] - pb[1] || pa[2] - pb[2];
              })
              .pop() || 'v0.0.0';
            let [major, minor, patch] = latest.slice(1).split('.').map(Number);
            const type = '${{ inputs.release_type }}';
            if (type === 'major') { major++; minor = 0; patch = 0; }
            else if (type === 'feature') { minor++; patch = 0; }
            else { patch++; }
            const version = `${major}.${minor}.${patch}`;
            core.setOutput('version', version);
            core.setOutput('tag', `v${version}`);
            core.info(`New version: ${version}`);

      - name: Update Cargo.toml version
        run: |
          sed -i 's/^version = ".*"/version = "${{ steps.version.outputs.version }}"/' Cargo.toml

      - name: Update CHANGES.md
        run: |
          DATE=$(date +%Y-%m-%d)
          VERSION="${{ steps.version.outputs.version }}"

          # Update changelog: move Unreleased content to new version section
          perl -i -0777 -pe '
            s/## Unreleased\n+(### New\n(.*?))?(\n### Changed\n(.*?))?(\n### Fixed\n(.*?))?\n+(?=##|\z)/
              "## Unreleased\n\n### New\n\n### Changed\n\n### Fixed\n\n" .
              "## '"$VERSION"' - '"$DATE"'\n" .
              ($2 ? "\n### New\n$2" : "") .
              ($4 ? "\n### Changed\n$4" : "") .
              ($6 ? "\n### Fixed\n$6" : "") .
              "\n"
            /se' CHANGES.md

      - name: Commit and tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Cargo.toml CHANGES.md
          git commit -m "Release ${{ steps.version.outputs.tag }}"
          git tag -a "${{ steps.version.outputs.tag }}" -m "Release ${{ steps.version.outputs.tag }}"
          git push origin main --tags

  build-binaries:
    name: Build ${{ matrix.target }}
    needs: version
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
            archive: tar.gz
            cross: true
          - target: aarch64-unknown-linux-musl
            os: ubuntu-latest
            archive: tar.gz
            cross: true
          - target: x86_64-unknown-illumos
            os: ubuntu-latest
            archive: tar.gz
            cross: true
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.version.outputs.tag }}

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross
        if: matrix.cross
        run: cargo install cross --git https://github.com/cross-rs/cross

      - name: Build binary
        env:
          BOX_CLIENT_ID: ${{ secrets.BOX_CLIENT_ID }}
          BOX_CLIENT_SECRET: ${{ secrets.BOX_CLIENT_SECRET }}
        run: |
          if [ "${{ matrix.cross }}" = "true" ]; then
            RUSTFLAGS="-C target-feature=+crt-static" cross build --release --target ${{ matrix.target }}
          else
            cargo build --release --target ${{ matrix.target }}
          fi
        shell: bash

      - name: Create archive
        run: |
          mkdir -p dist
          BINARY="target/${{ matrix.target }}/release/boxyncd"
          ARCHIVE="boxyncd-${{ needs.version.outputs.version }}-${{ matrix.target }}.tar.gz"

          mkdir -p staging/boxyncd
          cp "$BINARY" staging/boxyncd/
          cp config/boxyncd.example.toml staging/boxyncd/ 2>/dev/null || true
          cp systemd/boxyncd.service staging/boxyncd/ 2>/dev/null || true

          tar -czvf "dist/${ARCHIVE}" -C staging boxyncd
          echo "ARCHIVE=${ARCHIVE}" >> $GITHUB_ENV
        shell: bash

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: boxyncd-${{ matrix.target }}
          path: dist/*

  create-release:
    name: Create GitHub Release
    needs: [version, build-binaries]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.version.outputs.tag }}

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: boxyncd-*
          merge-multiple: true

      - name: List artifacts
        run: ls -la artifacts/

      - name: Extract release notes
        id: changelog
        run: |
          VERSION="${{ needs.version.outputs.version }}"
          NOTES=$(sed -n "/^## ${VERSION}/,/^## [0-9]/p" CHANGES.md | sed '$d')
          echo "$NOTES" > release-notes.md
          echo "Release notes:"
          cat release-notes.md

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.version.outputs.tag }}
          name: boxyncd ${{ needs.version.outputs.tag }}
          body_path: release-notes.md
          files: artifacts/*
          fail_on_unmatched_files: true
          draft: false
          prerelease: false

  deploy-docs:
    name: Deploy Versioned Docs
    needs: [version, create-release]
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Trigger docs workflow
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'docs.yml',
              ref: 'main',
              inputs: { tag: '${{ needs.version.outputs.tag }}' },
            });
